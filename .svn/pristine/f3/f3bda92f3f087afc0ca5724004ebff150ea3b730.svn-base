package com.evergrande.hdmp.usertags.action.sms;

import com.evergrande.hdmp.usertags.service.BigTaskBreakUtil;
import com.evergrande.hdmp.usertags.service.TaskBreakExecutor;
import org.junit.Assert;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author Changhua, Wu
 *         Created on: 2/23/16,2:30 PM
 */
public class LockFreeSequenceGeneratorTest {

    private final static Logger logger = LoggerFactory.getLogger( LockFreeSequenceGeneratorTest.class);


    Map<String, AtomicLong> histSequence = new ConcurrentHashMap<>();

    @Test
    public void testSequence(){


        int  maxValueToTest = 3354;

        TaskBreakExecutor breakExecutor = new TaskBreakExecutor("sendSms Test Task", 10 , maxValueToTest, false) {

            @Override
            public void onComplete(int taskId) {
                // dummy
            }

            @Override
            public void execOne(int taskId, long index) {
                countStart(taskId);
                String seqNum = LockFreeSequenceGenerator.getSmsSequenceNum();

                if(histSequence.containsKey( seqNum)) {
                    histSequence.get(seqNum).getAndIncrement();
                } else {
                    histSequence.put(seqNum, new AtomicLong(1L));
                }

                countComplete(taskId);
            }

            @Override
            public void execRange(int taskId, long start, long end) {
                // dummy function.
            }


            @Override
            protected void init() {
                // dummy function.
            }
        };


        BigTaskBreakUtil.breakExec( breakExecutor);
        Assert.assertEquals( LockFreeSequenceGenerator.sequenceTickNum.get(), maxValueToTest );

        Assert.assertEquals(histSequence.size(), maxValueToTest);
        for( Map.Entry<String, AtomicLong> entry : histSequence.entrySet()) {
            String seqNum = entry.getKey();
            long count = entry.getValue().get();
            Assert.assertTrue( (seqNum != null) && (seqNum.length() == 20) );
            Assert.assertTrue( count == 1 );
            logger.debug("seqNum = {}", seqNum);
        }

        histSequence.clear();
        // allowing test sequence RollBack;
        LockFreeSequenceGenerator.sequenceTickNum.set( LockFreeSequenceGenerator.MAX_ROLL_BACK_LIMIT - 2000);

        BigTaskBreakUtil.breakExec( breakExecutor);

        logger.debug(" sequenceTickNum.get() = {}", LockFreeSequenceGenerator.sequenceTickNum.get() );
        Assert.assertTrue(LockFreeSequenceGenerator.sequenceTickNum.get() >= 1320 );
        Assert.assertTrue(LockFreeSequenceGenerator.sequenceTickNum.get() <= 1400 );

        Assert.assertEquals(histSequence.size(), maxValueToTest);
        for( Map.Entry<String, AtomicLong> entry : histSequence.entrySet()) {
            String seqNum = entry.getKey();
            long count = entry.getValue().get();
            Assert.assertTrue( (seqNum != null) && (seqNum.length() == 20) );
            Assert.assertTrue( count == 1 );
            logger.debug("seqNum = {}", seqNum);
        }
    }
}
