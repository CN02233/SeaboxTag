package com.evergrande.hdmp.usertags.action.job.engine.stage1;

import com.evergrande.hdmp.usertags.action.CampaignActionStatus;
import com.evergrande.hdmp.usertags.action.job.ControllableThreadBase;
import com.evergrande.hdmp.usertags.action.job.engine.ProcessStage;
import com.evergrande.hdmp.usertags.action.job.engine.TaskQueue_Scan_to_1;
import com.evergrande.hdmp.usertags.entity.CampInfo;
import com.evergrande.hdmp.usertags.hbase.CampaignActionStore;
import com.evergrande.hdmp.usertags.hbase.CampaignActionStoreHBaseImpl;
import com.evergrande.hdmp.usertags.hbase.HBaseConnectionMgr;
import com.evergrande.hdmp.usertags.hbase.entity.TCampInfo;
import com.evergrande.hdmp.usertags.mybatis.dao.CampInfoDao;
import com.evergrande.hdmp.usertags.service.BigTaskBreakUtil;
import com.evergrande.hdmp.usertags.service.TaskBreakExecutor;
import com.evergrande.hdmp.usertags.service.impl.CacheServiceRedisImpl;
import com.evergrande.hdmp.usertags.utils.SingletonBean;
import org.apache.hadoop.hbase.client.Connection;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;

import javax.annotation.PreDestroy;
import java.io.IOException;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;

/**
 *  prepare Stage:  Redis GUIDs for Camp --> Hbase
 *
 * Created by wuchh on 3/9/16.
 */
@SingletonBean
public class Stage1Engine_PrepareCampTask extends ControllableThreadBase implements ProcessStage<CampInfo> {

    private static final Logger logger = LoggerFactory.getLogger(Stage1Engine_PrepareCampTask.class);

    @Autowired
    private TaskQueue_Scan_to_1 taskQueue;

    @Autowired
    private HBaseConnectionMgr connectionMgr;

    @Autowired
    private CampInfoDao    campInfoDao;

    @Autowired
    private JedisPool jedisPool;

    private AtomicLong count_prepareAction = new AtomicLong(0);


    private ExecutorService stageExecutor = Executors.newFixedThreadPool(10); // maximum 10 in-parallel allowed

    public final static int MAX_THREADS_FOR_SUB = 10;


    @PreDestroy
    public void shutdown() {

        stageExecutor.shutdownNow();

    }


    @Override
    public void processStage(CampInfo campInfo) {

        final CampInfo campInfoToExec = campInfo;

        Runnable runPrepareAction = new Runnable() {
            @Override
            public void run() {
                prepareAction( campInfoToExec );
            }
        };

        stageExecutor.submit( runPrepareAction );

    }


    @Override
    public void doWork() {

        try {
            CampInfo campInfo = taskQueue.blockingConsume();

            processStage(campInfo);

        } catch (InterruptedException e) {
            logger.error("I was Interrupted : " + this, e);

            Thread myThread = Thread.currentThread();
            myThread.interrupt();
        }

    }


    @Override
    public Map<String, String> getStatsMap() {
        Map<String, String>  statsMap = super.getStatsMap();
        statsMap.put("prepareAction", count_prepareAction.toString());
        return statsMap;
    }


    public void  prepareAction(CampInfo campInfo) {

        String campId = campInfo.getCamp_id();

        count_prepareAction.getAndIncrement();


        logger.info("============= started prepareAction() for camp:{} =============", campId );


        String camp_channel = campInfo.getCamp_chnl_cd();
        String  camp_industry = campInfo.getCamp_inds_cd();
        Set<String> excludeUsersFromMysql = campInfoDao.getExcludeUserList(camp_channel, camp_industry);

        if(null == excludeUsersFromMysql) {
            excludeUsersFromMysql = new HashSet<>(); //default, Empty Set
        }

        final Set<String> excludeUsers = excludeUsersFromMysql;

        try ( Connection hBaseCon = connectionMgr.getConnection();
              CampaignActionStore campaignActionStore = CampaignActionStoreHBaseImpl.createInstance(campId, hBaseCon)) {

            TCampInfo campInfoRecord = campaignActionStore.findOneCampInfoRecord( campId );

            if(campInfoRecord == null) {

                logger.error("============= prepareAction() Failed for camp:{} , can not find campInfoRecord in hbase  =============", campId );

            } else {

                String usersKeyRedis = campInfoRecord.getUsersKeyInRedis();
                if (usersKeyRedis == null) {

                    campaignActionStore.updateCampActionDetailStatus(CampaignActionStatus.PREPARE_FAILED );
                    logger.error("============= prepareAction() Failed for camp:{} , usersKeyRedis is null =============", campId );


                } else {


                    try (Jedis jedis = jedisPool.getResource()
                    ) {

                        final String campUsersKeyRedis = CacheServiceRedisImpl.getCampUsersRedisKey(campId);
                        final long userCount = jedis.llen( campUsersKeyRedis);

                        TaskBreakExecutor breakExecutor = new TaskBreakExecutor("prepareAction-subTasks:campId=" + campId,  MAX_THREADS_FOR_SUB, userCount, false ) {

                            Jedis[] jedisSubs;

                            @Override
                            protected void init() {
                                jedisSubs = new Jedis[ MAX_THREADS_FOR_SUB ];
                                for(int i=0; i< jedisSubs.length; ++i) {
                                    jedisSubs[i] = jedisPool.getResource();
                                }
                            }

                            @Override
                            public void onComplete(int taskId) {
                                jedisSubs[ taskId ].close();
                            }

                            @Override
                            public void execOne(int taskId, long index) {
                                countStart( taskId );
                                String userGUID = jedisSubs[taskId].lpop(campUsersKeyRedis);
                                if (userGUID != null) {
                                    campaignActionStore.addUserToCampaignAction(userGUID, excludeUsers);
                                    countComplete(taskId);
                                } else {
                                    countError( taskId );
                                    logger.error("prepareAction() segmentTask got null of userGUID from Redis, index={}, userCount={}", index, userCount);
                                }

                            }

                            @Override
                            public void execRange(int taskId, long start, long end) {
                                //dummy, we use execOne
                            }


                        } ;

                        BigTaskBreakUtil.breakExec( breakExecutor);

                        final long remainUserCount = jedis.llen( campUsersKeyRedis);
                        logger.info("prepareAction() campId={} remainUserCount={}", campId, remainUserCount);

                        campaignActionStore.updateCampActionDetailStatus(CampaignActionStatus.READY );

                        jedis.del(campUsersKeyRedis); // delete this Cache, all info had transfer to hBase, no more required in Redis.

                    }

                }

            }

            logger.info("============= complete prepareAction() for camp:{} =============", campId );

        } catch (IOException e) {
            logger.error("============= prepareAction() failed for camp:" + campId + " =============", e);
        }




    }

}
